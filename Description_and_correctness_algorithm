Описание алгоритма
Алгоритм принимает на вход регулярное выражение в обратной польской записи в виде строки. Заводим стек, где будем поддерживать для каждого значения unordered_set, ключами которого будут значения от 0 до k, то есть количества букв x в слове, а значениями будет минимальная длина слова для данного ключа. Определяем такие пары только если возможно данное количество букв x в слове. Далее начинаем рассматривать регулярку: прочитываем
    1) Символ, если буква, то заводим unordered_set для данной буквы (нашего слова в данный момент) далее возможны два случая: если эта буква совпадает с той которая дана в условии то в сете пишем [1] = 1, иначе [0] = 1, и пушим наш сет в стек. Если на входе 1, то [0] = 0
    2) Операция . (конкатенации). Вытаскиваем из стека два последних слова и просто соединяем их. То есть в цикле проходимся по ключам первого выражение, для каждого ключа из первого проходимся по ключам второго выражения, таким образом рассматриваем все возможные значения количества букв х в слове, которое получается в результате конкатенации. Далее просто для каждого ключа записываем минимум из суммы длин двух слов и предыдущего (если есть) результата. Тем самым мы поддерживаем для каждого ключа минимальное значение длины слова
    3) Операция + (сложение двух слов) Вытаскиваем из стека два последних слова. Просто идем циклом от 0 до k. Если данный ключ существует у двух слов, то записываем в результирующее слово минимум от длины двух слов. Если только у одного, то значение длины этого слова по данному ключу. Таким образом на выходе будет слово, для каждого ключа которого записана минимальная длина
    4) Операция * (звезда клини). Вытаскиваем из стека одно слово (тк операция унарная). Результат: ключу 0 всегда будет соответствовать значение длины 0, для остальных ключей ищем минимальную возможную длину: проходимся по парам ключей, которые в сумме дадут искомый ключ и имем минимальную сумму длин. Как прошлись: если нашли минимум то записываем минимум из старого значения слова и нового минимума для данного ключа, если не нашли, то просто записываем старое значение ключа. Таким образом каждое значение ключа будет результатом комбинации меньших значений ключа, что позволит найти минимальную длину для каждого ключа.
Рассмотрев все символы, если изначальная польская записть была корректно задана, то в стеке будет хранится все наше регулярное выражение (то есть unordered_map для него) Тогда мы просто берем значение по нашему ключу k. Если оно есть то выводим ответ, если нет то выводим INF

Корректность алгоритма
Так как регулярное выражение задано в обратной польской записи, то с помощью стека в конечном итоге у нас склеится полное регулярное выражение (сет для него), если мы будем действовать по алгоритму.
Далее будем рассматривать в том ключе, что каждый результат это наше итоговое слово и для каждого такого слова мы должны поддерживать корректность, тогда общий результат тоже будет корректным, осталось рассмотреть алгоритм каждой операции
Докажем, что для в результате каждой операции получается корректно заполненый unordered_set. Операция “.” очевидно, так как мы рассматриваем все возможные комбинации ключей двух слов и для каждого ключа записываем минимум в результате. Аналогично для “+” мы просто для каждого ключа записываем минимальное значение от двух рассматриваемых слов, следовательно значения ключей в результате тоже будут минимальными. И операция “*” доказывается по индукции: База: для того, чтобы было 0 букв x минимальная длина слова будет 0 (тк звезда клини позволяет взять просто пустое слово), пусть значение задано верно для ключа k, тогда рассмотрим для k + 1. Чтобы получить в слове kc+ 1 букв х, мы или берем значение ключа старого слова или применяя звезду клини берем разные слова, с ключами меньше k + 1, чтобы в сумме по ключам набрать необходимое нам, но когда мы рассматриваем значения для ключей меньших k + 1, то они у нас минимальные (по индукции), следовательно для нашего рассматриваемого значения мы тоже получим минимум.
